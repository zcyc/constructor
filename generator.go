package main

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
	"text/template"
)

// Generator generates constructor code
type Generator struct {
	config *GeneratorConfig
	info   *StructInfo
}

// NewGenerator creates a new generator
func NewGenerator(config *GeneratorConfig, info *StructInfo) *Generator {
	return &Generator{
		config: config,
		info:   info,
	}
}

// Generate generates constructor code based on configuration
func (g *Generator) Generate() (string, error) {
	var buf bytes.Buffer

	// Write package declaration
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.info.PackageName))
	buf.WriteString("// Code generated by constructor. DO NOT EDIT.\n\n")

	fields := g.info.GetFieldsForConstructor()

	// Generate constructors based on types
	for _, constructorType := range g.config.ConstructorTypes {
		switch constructorType {
		case "allArgs":
			code, err := g.generateAllArgsConstructor(fields)
			if err != nil {
				return "", err
			}
			buf.WriteString(code)
			buf.WriteString("\n\n")

		case "builder":
			code, err := g.generateBuilderConstructor(fields)
			if err != nil {
				return "", err
			}
			buf.WriteString(code)
			buf.WriteString("\n\n")

		case "options":
			code, err := g.generateOptionsConstructor(fields)
			if err != nil {
				return "", err
			}
			buf.WriteString(code)
			buf.WriteString("\n\n")

		default:
			return "", fmt.Errorf("unknown constructor type: %s", constructorType)
		}
	}

	// Generate getters if requested
	if g.config.WithGetter {
		getterFields := g.info.GetFieldsForGetter()
		code := g.generateGetters(getterFields)
		buf.WriteString(code)
		buf.WriteString("\n")
	}

	// Format and fix imports using goimports
	code := buf.String()

	// Try to run goimports to fix imports and format
	cmd := exec.Command("goimports")
	cmd.Stdin = strings.NewReader(code)
	var out bytes.Buffer
	cmd.Stdout = &out
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		// If goimports fails, return the unformatted code with a warning
		return code, fmt.Errorf("goimports not available or failed: %w (install with: go install golang.org/x/tools/cmd/goimports@latest)", err)
	}

	return out.String(), nil
}

// generateAllArgsConstructor generates a constructor with all fields as parameters
func (g *Generator) generateAllArgsConstructor(fields []FieldInfo) (string, error) {
	tmpl := `// New{{.StructName}} creates a new {{.StructName}}
func New{{.StructName}}({{.Params}}) {{.ReturnType}} {
	{{.VarDecl}}{{.StructName}}{
		{{.FieldAssignments}}
	}{{.InitCall}}{{if .ReturnValue}}
	return {{.ReturnValue}}{{end}}
}`

	params := []string{}
	assignments := []string{}

	for _, field := range fields {
		paramName := toLowerCamelCase(field.Name)
		params = append(params, fmt.Sprintf("%s %s", paramName, field.Type))
		assignments = append(assignments, fmt.Sprintf("%s: %s,", field.Name, paramName))
	}

	returnType := "*" + g.info.Name
	varDecl := "return &"
	returnValue := ""

	if g.config.ReturnValue {
		returnType = g.info.Name
		varDecl = "return "
		returnValue = ""
	}

	// Handle init function
	initCall := ""
	if g.config.InitFunc != "" {
		if g.config.ReturnValue {
			varDecl = "v := "
			returnValue = "v"
		} else {
			varDecl = "v := &"
			returnValue = "v"
		}
		initCall = fmt.Sprintf("\n\tv.%s()", g.config.InitFunc)
	} else {
		// No init function, so returnValue stays empty for direct return
		returnValue = ""
	}

	data := map[string]string{
		"StructName":       g.info.Name,
		"Params":           strings.Join(params, ", "),
		"ReturnType":       returnType,
		"VarDecl":          varDecl,
		"FieldAssignments": strings.Join(assignments, "\n\t\t"),
		"InitCall":         initCall,
		"ReturnValue":      returnValue,
	}

	t, err := template.New("allArgs").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateBuilderConstructor generates a builder pattern constructor
func (g *Generator) generateBuilderConstructor(fields []FieldInfo) (string, error) {
	var buf bytes.Buffer

	builderName := g.info.Name + "Builder"
	prefix := g.config.SetterPrefix
	if prefix == "" {
		prefix = "" // No prefix by default, methods named after fields
	}

	// Generate builder struct
	buf.WriteString(fmt.Sprintf("// %s is a builder for %s\n", builderName, g.info.Name))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", builderName))
	for _, field := range fields {
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toLowerCamelCase(field.Name), field.Type))
	}
	buf.WriteString("}\n\n")

	// Generate builder constructor
	buf.WriteString(fmt.Sprintf("// New%s creates a new %s\n", builderName, builderName))
	buf.WriteString(fmt.Sprintf("func New%s() *%s {\n", builderName, builderName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{}\n", builderName))
	buf.WriteString("}\n\n")

	// Generate setter methods
	for _, field := range fields {
		methodName := prefix + toUpperCamelCase(field.Name)
		paramName := toLowerCamelCase(field.Name)
		fieldName := toLowerCamelCase(field.Name)

		buf.WriteString(fmt.Sprintf("// %s sets the %s field\n", methodName, field.Name))
		buf.WriteString(fmt.Sprintf("func (b *%s) %s(%s %s) *%s {\n",
			builderName, methodName, paramName, field.Type, builderName))
		buf.WriteString(fmt.Sprintf("\tb.%s = %s\n", fieldName, paramName))
		buf.WriteString("\treturn b\n")
		buf.WriteString("}\n\n")
	}

	// Generate Build method
	returnType := "*" + g.info.Name
	if g.config.ReturnValue {
		returnType = g.info.Name
	}

	buf.WriteString(fmt.Sprintf("// Build builds the %s\n", g.info.Name))
	buf.WriteString(fmt.Sprintf("func (b *%s) Build() %s {\n", builderName, returnType))

	if g.config.ReturnValue {
		buf.WriteString(fmt.Sprintf("\tv := %s{\n", g.info.Name))
	} else {
		buf.WriteString(fmt.Sprintf("\tv := &%s{\n", g.info.Name))
	}

	for _, field := range fields {
		paramName := toLowerCamelCase(field.Name)
		buf.WriteString(fmt.Sprintf("\t\t%s: b.%s,\n", field.Name, paramName))
	}
	buf.WriteString("\t}\n")

	// Handle init function
	if g.config.InitFunc != "" {
		buf.WriteString(fmt.Sprintf("\tv.%s()\n", g.config.InitFunc))
	}

	buf.WriteString("\treturn v\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateOptionsConstructor generates a functional options pattern constructor
func (g *Generator) generateOptionsConstructor(fields []FieldInfo) (string, error) {
	var buf bytes.Buffer

	optionType := g.info.Name + "Option"
	returnType := "*" + g.info.Name
	if g.config.ReturnValue {
		returnType = g.info.Name
	}

	// Generate option type
	buf.WriteString(fmt.Sprintf("// %s is a functional option for configuring %s\n", optionType, g.info.Name))
	buf.WriteString(fmt.Sprintf("type %s func(*%s)\n\n", optionType, g.info.Name))

	// Generate option functions
	for _, field := range fields {
		optionName := "With" + toUpperCamelCase(field.Name)
		paramName := toLowerCamelCase(field.Name)

		buf.WriteString(fmt.Sprintf("// %s sets the %s field\n", optionName, field.Name))
		buf.WriteString(fmt.Sprintf("func %s(%s %s) %s {\n", optionName, paramName, field.Type, optionType))
		buf.WriteString(fmt.Sprintf("\treturn func(s *%s) {\n", g.info.Name))
		buf.WriteString(fmt.Sprintf("\t\ts.%s = %s\n", field.Name, paramName))
		buf.WriteString("\t}\n")
		buf.WriteString("}\n\n")
	}

	// Generate constructor with options
	buf.WriteString(fmt.Sprintf("// New%sWithOptions creates a new %s with functional options\n", g.info.Name, g.info.Name))
	buf.WriteString(fmt.Sprintf("func New%sWithOptions(opts ...%s) %s {\n", g.info.Name, optionType, returnType))

	if g.config.ReturnValue {
		buf.WriteString(fmt.Sprintf("\tv := &%s{}\n", g.info.Name))
	} else {
		buf.WriteString(fmt.Sprintf("\tv := &%s{}\n", g.info.Name))
	}

	buf.WriteString("\tfor _, opt := range opts {\n")
	buf.WriteString("\t\topt(v)\n")
	buf.WriteString("\t}\n")

	// Handle init function
	if g.config.InitFunc != "" {
		buf.WriteString(fmt.Sprintf("\tv.%s()\n", g.config.InitFunc))
	}

	if g.config.ReturnValue {
		buf.WriteString("\treturn *v\n")
	} else {
		buf.WriteString("\treturn v\n")
	}
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateGetters generates getter methods for all fields
func (g *Generator) generateGetters(fields []FieldInfo) string {
	var buf bytes.Buffer

	for _, field := range fields {
		if !field.Exported {
			getterName := "Get" + toUpperCamelCase(field.Name)
			receiverName := strings.ToLower(string(g.info.Name[0]))

			buf.WriteString(fmt.Sprintf("// %s returns the %s field\n", getterName, field.Name))
			buf.WriteString(fmt.Sprintf("func (%s *%s) %s() %s {\n",
				receiverName, g.info.Name, getterName, field.Type))
			buf.WriteString(fmt.Sprintf("\treturn %s.%s\n", receiverName, field.Name))
			buf.WriteString("}\n\n")
		}
	}

	return buf.String()
}

// toLowerCamelCase converts a string to lowerCamelCase
func toLowerCamelCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}

// toUpperCamelCase converts a string to UpperCamelCase
func toUpperCamelCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
